## array

* 固定大小的数组，其大小在编译时确定。
* 元素在内存中是连续存储的，类似于原生数组。
* 提供常量时间的访问，不支持动态大小调整。
* 适用于已知大小且不需要动态调整的情况。

```cpp
#include <array>
std::array<int, 3> myArray = {1, 2, 3};
```

## list

* 是一个双向链表，元素在内存中非连续存储。
* 提供常数时间的插入和删除，但访问时间较长。
* 不支持随机访问，需要通过迭代器遍历。
* 适用于频繁插入和删除的场景，不适合需要随机访问的情况。

```cpp
#include <list>
std::list<int> myList = {1, 2, 3};
</code></div></div></pre>
```

## vector

* 是一个动态数组，元素在内存中是连续存储的。
* 提供常数时间的随机访问，但插入和删除可能需要线性时间。
* 支持动态调整大小，自动处理内存管理。
* 适用于需要频繁访问元素或在尾部插入/删除元素的情况。

```cpp
#include <vector>
std::vector<int> myVector = {1, 2, 3};
```

## deque

* 是一个双端队列（double-ended queue），支持在两端高效地插入和删除元素。
* 元素在内存中是分块存储的，可以高效地在两端进行操作。
* 提供常数时间的随机访问，以及常数时间的在两端插入和删除。
* 支持动态调整大小，自动处理内存管理。

```cpp
#include <deque>
std::deque<int> myDeque = {1, 2, 3};
```

## stack

* 是一个栈（stack）容器，基于其他容器实现的适配器。
* 提供后进先出（LIFO）的元素访问方式。
* 默认基于 `std::deque` 实现，但可以选择其他容器作为底层实现。
* 提供 `push`（压栈）、`pop`（出栈）、`top`（访问栈顶元素）等操作。

```cpp
#include <stack>
std::stack<int> myStack;
```

## set

* 是一个集合（set）容器，存储唯一的元素，且按照一定的排序规则自动排序。
* 内部实现通常基于红黑树（Red-Black Tree）或类似的平衡二叉搜索树结构。
* 提供插入、删除和查找操作的对数时间复杂度。
* 适用于需要存储唯一元素并按顺序访问的场景。

```cpp
#include <set>
std::set<int> mySet = {3, 1, 4, 1, 5, 9};
```

## map

* 是一个关联数组（associative array）容器，存储键值对，并按照键的顺序自动排序。
* 内部实现通常基于红黑树或类似的平衡二叉搜索树结构。
* 提供插入、删除和查找操作的对数时间复杂度。
* 适用于需要存储键值对并按键的顺序访问的场景。

```cpp
#include <map>
std::map<std::string, int> myMap = {{"one", 1}, {"two", 2}, {"three", 3}};
```
