## 原子锁

● 相关问题

多个线程对同一个数据进行原子操作(运算符操作)，会产生结果丢失。比如执行++运算时

● 错误代码分析

当线程 A 执行 g_value ++时,如果线程切换时间正好是在线程 A 将值保存到 g_value 前,线程 B 继续执行 g_value ++,那么线程 A 再次被切换回来之后,会将之前线程 A 保存的 g_value 上,线程 B 进行的加法操作被覆盖

```cpp
// 打断点 右键转到反汇编
// eax是寄存器
mov         eax,dword ptr [g_value (07FF66681D170h)]  // eax = g_value
inc         eax                      // eax = eax + 1
mov         dword ptr [g_value (07FF66681D170h)],eax  // g_value = eax

// 如果在第二步切换,此时还未保存, 切到B线程后, 正常储存,再切回A,执行第三步,就会损失结果
```

● 使用原子锁函数

只能对操作符锁

InterlockedIncrement(&g_valu) => g_value++
InterlockedDecrement(&g_valu => g_value--
InterlockedCompareExchange => 三目
InterlockedExchanqe => 等于

原子锁的实现:直接对数据所在的内存操作，并且在任何一个瞬间只能有一个线程访问

## 互斥锁

● 相关的问题

多线程下代码或资源的共享使用

● 互斥的使用

- 任意时间点, 只能有一个线程拥有该互斥
- 所有线程都不拥有互斥, 有信号

1 创建互斥

```cpp
HANDLE CreateMutex(
  LPSECURITY_ATTRIBUTES IpMutexAttributes, //安全属性 置空
  BOOL bInitialOwner//初始的拥有者 TRUE/FALSE
  LPCTSTR IpName //命名
);创建成功返回互斥句柄(也是可等候句柄)
```

2 等候互斥

WaitFor...

如: WaitForSingleObject(mutex_handle, INFINITE);

互斥的等候遵循谁先等候谁先获取，

3 释放互斥

```cpp
BOOL ReleaseMutex(
  HANDLE hMutex // handle to mutex
);
```

4 关闭互斥句柄

CloseHandle

示例

```cpp
HANDLE mutex_handle;

DWORD CALLBACK thread_func(LPVOID lpParam) {
  WaitForSingleObject(mutex_handle, INFINITE);
  // 访问被互斥的代码块
  std::cout << "Hello, world!" << std::endl;
  ReleaseMutex(mutex_handle);
  return 0;
}

int main() {
  mutex_handle = CreateMutex(NULL, FALSE, NULL);

  HANDLE thread = CreateThread(NULL, 0, thread_func, NULL, 0, NULL);
  if (thread == NULL) {
    std::cerr << "Failed to create thread." << std::endl;
    return 1;
  }

  WaitForSingleObject(thread, INFINITE);
  CloseHandle(thread);
  CloseHandle(mutex_handle);
  return 0;
}
```
